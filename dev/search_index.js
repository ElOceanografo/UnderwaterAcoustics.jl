var documenterSearchIndex = {"docs":
[{"location":"index.html#UnderwaterAcoustics.jl","page":"Home","title":"UnderwaterAcoustics.jl","text":"","category":"section"},{"location":"index.html#Julia-toolbox-for-Underwater-acoustic-modeling","page":"Home","title":"Julia toolbox for Underwater acoustic modeling","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = UnderwaterAcoustics","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"julia>]\npkg> add https://github.com/org-arl/UnderwaterAcoustics.jl","category":"page"},{"location":"index.html#Propagation-modeling","page":"Home","title":"Propagation modeling","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To get started:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using UnderwaterAcoustics","category":"page"},{"location":"index.html#Define-an-environment","page":"Home","title":"Define an environment","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"First, let's setup an environment description.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> env = UnderwaterEnvironment()\nBasicUnderwaterEnvironment:\n  altimetry = FlatSurface()\n  bathymetry = ConstantDepth{Float64}(20.0)\n  ssp = IsoSSP{Float64}(1539.0866009307247)\n  salinity = 35.0\n  seasurface = SurfaceLoss{Float64}(2.6)\n  seabed = RayleighReflectionCoef{Float64,Float64,Float64}(1.169, 0.9999, 0.01261)\n  noise = RedGaussianNoise{Float64}(1.0e6)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Environments are immutable, so you have to customize them during construction. For example:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> env = UnderwaterEnvironment(\n         seasurface = Vacuum,\n         seabed = SandyClay,\n         ssp = SampledSSP(0.0:20.0:40.0, [1500.0, 1490.0, 1520.0], :smooth),\n         bathymetry = ConstantDepth(40.0)\n       )\nBasicUnderwaterEnvironment:\n  altimetry = FlatSurface()\n  bathymetry = ConstantDepth{Float64}(40.0)\n  ssp = SampledSSP{Float64,Float64,linear}(3 points)\n  salinity = 35.0\n  seasurface = ReflectionCoef{Float64}(-1.0)\n  seabed = RayleighReflectionCoef{Float64,Float64,Float64}(1.147, 0.9849, 0.00242)\n  noise = RedGaussianNoise{Float64}(1.0e6)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Currently available options:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Altimetry – FlatSurface()\nBathymetry – ConstantDepth(depth), SampledDepth(ranges, depths, interp)\nSSP – IsoSSP(soundspeed), MunkSSP(), SampledSSP(depths, soundspeeds, interp)\nSeasurface – ReflectionCoef(R), RayleighReflectionCoef(relativedensity, relativesoundspeed, attenuation), Vacuum, SeaState0, SeaState1, SeaState2, SeaState3, SeaState4, SeaState5, SeaState6, SeaState7, SeaState8, SeaState9\nSeabed – ReflectionCoef(R), RayleighReflectionCoef(relativedensity, relativesoundspeed, attenuation), Rock, Pebbles, SandyGravel, CoarseSand, MediumSand, FineSand, VeryFineSand, ClayeySand, CoarseSilt, SandySilt, Silt, FineSilt, SandyClay, SiltyClay, Clay\nNoise – RedGaussianNoise(σ) or any other distribution that works with rand()","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"and interp is either :linear or :smooth.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If you have Plots.jl installed, you can use plot recipes to plot the environment or the soundspeed profile. For example:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using Plots\njulia> plot(ssp(env))","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"index.html#Selecting-a-model","page":"Home","title":"Selecting a model","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Once you have an environment, you need to select a propagation model. To get a list of all available models:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> models()\n3-element Array{Any,1}:\n PekerisRayModel\n RaySolver\n Bellhop","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"NOTE: Bellhop will only be available if you have a working copy of OALIB bellhop.exe available on your PATH.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Once you have an environment, you can select a model that can work with that environment:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> models(env)\n2-element Array{Any,1}:\n RaySolver\n Bellhop","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In this case, we got a shorter list back because the PekerisRayModel can't deal with non-isovelocity SSP. We can confirm this by creating an iso-velocity environment:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> env = UnderwaterEnvironment()\nBasicUnderwaterEnvironment:\n  altimetry = FlatSurface()\n  bathymetry = ConstantDepth{Float64}(20.0)\n  ssp = IsoSSP{Float64}(1539.0866009307247)\n  salinity = 35.0\n  seasurface = SurfaceLoss{Float64}(2.6)\n  seabed = RayleighReflectionCoef{Float64,Float64,Float64}(1.169, 0.9999, 0.01261)\n  noise = RedGaussianNoise{Float64}(1.0e6)\n\njulia> models(env)\n2-element Array{Any,1}:\n PekerisRayModel\n RaySolver","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This time you see that Bellhop wasn't included, as it assumes a Vacuum surface by default and we have a SeaState1 surface as our default.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We summarize the currently available models:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Model Description Strengths Limitations\nPekerisRayModel Analytical ray model for Pekeris waveguides Fast, differentiable, multi-threaded Isovelocity, range independent\nBellhop Interface to OALIB's FORTRAN Bellhop model Well established Does not support automatic differentiation or probabilistic programming\nRaySolver Julia Ray/Gaussian beam model, similar to Bellhop Differentiable, multi-threaded Tell us and we'll fix them!","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"NOTE: Support for range-dependent environments is still underway. RaySolver models are currently only partially differentiable (unable to differentiate w.r.t. receiver location and bathymetry).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Let's pick a 7-ray Pakeris ray model for now:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> pm = PekerisRayModel(env, 7)\nPekerisRayModel with BasicUnderwaterEnvironment:\n  altimetry = FlatSurface()\n  bathymetry = ConstantDepth{Float64}(20.0)\n  ssp = IsoSSP{Float64}(1539.0866009307247)\n  salinity = 35.0\n  seasurface = SurfaceLoss{Float64}(2.6)\n  seabed = RayleighReflectionCoef{Float64,Float64,Float64}(1.169, 0.9999, 0.01261)\n  noise = RedGaussianNoise{Float64}(1.0e6)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If you wanted the ray solver instead, you'd do pm = RaySolver(env), or for a Bellhop model, you'd do pm = Bellhop(env). Both models can take additional keyword parameters that can customize the solver. For details, see the type definitions in the sources (RaySolver, Bellhop).","category":"page"},{"location":"index.html#Defining-sources-and-receivers","page":"Home","title":"Defining sources and receivers","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Now, we need a source and a receiver:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> tx = AcousticSource(0.0, -5.0, 1000.0);\njulia> rx = AcousticReceiver(100.0, -10.0);","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This defines an omnidirectional 1 kHz transmitter tx at a depth of 5 m at the origin, and an omnidirectional receiver at a range of 100 m and a depth of 10 m.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"NOTE: All coordinates are specified in meters as (x, y, z) for 3D or (x, z) for 2D. The coordinate system has x and y axis in the horizontal plane, and z axis pointing upwards, with the nominal water surface being at 0 m. This means that all z coordinates in water are negative.","category":"page"},{"location":"index.html#Ray-tracing","page":"Home","title":"Ray tracing","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Now that we have an environment, a propation model, a transmitter and a receiver, we can modeling. First, we ask for all eigenrays between the transmitter and receiver:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> r = eigenrays(pm, tx, rx)\n7-element Array{UnderwaterAcoustics.RayArrival{Float64,Complex{Float64},Float64,Float64,Float64},1}:\n ∠ -2.9°  0↑  0↓ ∠  2.9° |  65.05 ms | -40.0 dB ϕ  -0.0° ⤷\n ∠  8.5°  1↑  0↓ ∠  8.5° |  65.70 ms | -41.0 dB ϕ 180.0° ⤷\n ∠-14.0°  0↑  1↓ ∠-14.0° |  66.97 ms | -59.0 dB ϕ  60.5° ⤷\n ∠ 19.3°  1↑  1↓ ∠-19.3° |  68.84 ms | -61.7 dB ϕ-141.7° ⤷\n ∠-24.2°  1↑  1↓ ∠ 24.2° |  71.25 ms | -62.6 dB ϕ-153.8° ⤷\n ∠ 28.8°  2↑  1↓ ∠ 28.8° |  74.15 ms | -63.5 dB ϕ  19.4° ⤷\n ∠-33.0°  1↑  2↓ ∠-33.0° |  77.49 ms | -85.7 dB ϕ-149.4° ⤷","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For each eigenray, this shows us the launch angle, number of surface bounces, number of bottom bounces, arrival angle, travel time, transmission loss along that ray, and phase change. The last \"⤷\" symbol indicates that the complete ray path is also available. We can plot the ray paths:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> plot(env; sources=[tx], receivers=[rx], rays=r)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Th red star is the transmitter and the blue circle is the receiver. The stronger eigenrays are shown in blue, while the weaker ones are shown in red.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We might sometimes want to see all rays from the transmitter at certain angular spacing (-45°:5°:45°) and a given range (100 m):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> r = rays(pm, tx, -45°:5°:45°, 100.0)\n19-element Array{UnderwaterAcoustics.RayArrival{Float64,Complex{Float64},Float64,Float64,Float64},1}:\n ∠-45.0°  2↑  3↓ ∠-45.0° |  91.89 ms | -109.6 dB ϕ  27.5° ⤷\n ∠-40.0°  2↑  2↓ ∠ 40.0° |  84.82 ms | -86.8 dB ϕ  22.1° ⤷\n ∠-35.0°  1↑  2↓ ∠-35.0° |  79.32 ms | -85.9 dB ϕ-152.3° ⤷\n ∠-30.0°  1↑  2↓ ∠-30.0° |  75.03 ms | -85.2 dB ϕ-143.9° ⤷\n ∠-25.0°  1↑  1↓ ∠ 25.0° |  71.69 ms | -62.8 dB ϕ-155.2° ⤷\n ∠-20.0°  1↑  1↓ ∠ 20.0° |  69.14 ms | -61.9 dB ϕ-143.9° ⤷\n ∠-15.0°  0↑  1↓ ∠-15.0° |  67.27 ms | -59.6 dB ϕ  55.5° ⤷\n ⋮\n ∠ 15.0°  1↑  1↓ ∠-15.0° |  67.27 ms | -60.0 dB ϕ-124.5° ⤷\n ∠ 20.0°  1↑  1↓ ∠-20.0° |  69.14 ms | -61.9 dB ϕ-143.9° ⤷\n ∠ 25.0°  2↑  1↓ ∠ 25.0° |  71.69 ms | -63.1 dB ϕ  24.8° ⤷\n ∠ 30.0°  2↑  1↓ ∠ 30.0° |  75.03 ms | -63.6 dB ϕ  18.1° ⤷\n ∠ 35.0°  2↑  2↓ ∠-35.0° |  79.32 ms | -86.2 dB ϕ  27.7° ⤷\n ∠ 40.0°  2↑  2↓ ∠-40.0° |  84.82 ms | -86.8 dB ϕ  22.1° ⤷\n ∠ 45.0°  3↑  2↓ ∠ 45.0° |  91.89 ms | -87.7 dB ϕ-161.7° ⤷\n\njulia> plot(env; sources=[tx], rays=r)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"index.html#Arrivals-and-transmission-loss","page":"Home","title":"Arrivals & transmission loss","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Often, we are interested in the arrival structure or transmission loss at a receiver. Getting the arrivals is quite similar to getting eigenrays, but the ray paths are not stored:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> a = arrivals(pm, tx, rx)\n7-element Array{UnderwaterAcoustics.RayArrival{Float64,Complex{Float64},Float64,Float64,Missing},1}:\n ∠ -2.9°  0↑  0↓ ∠  2.9° |  65.05 ms | -40.0 dB ϕ  -0.0°\n ∠  8.5°  1↑  0↓ ∠  8.5° |  65.70 ms | -41.0 dB ϕ 180.0°\n ∠-14.0°  0↑  1↓ ∠-14.0° |  66.97 ms | -59.0 dB ϕ  60.5°\n ∠ 19.3°  1↑  1↓ ∠-19.3° |  68.84 ms | -61.7 dB ϕ-141.7°\n ∠-24.2°  1↑  1↓ ∠ 24.2° |  71.25 ms | -62.6 dB ϕ-153.8°\n ∠ 28.8°  2↑  1↓ ∠ 28.8° |  74.15 ms | -63.5 dB ϕ  19.4°\n ∠-33.0°  1↑  2↓ ∠-33.0° |  77.49 ms | -85.7 dB ϕ-149.4°","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If we prefer, we can plot these arrivals as an impulse response (sampled at 44.1 kSa/s, in this case):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> plot(abs.(impulseresponse(a, 44100)); xlabel=\"Sample #\", legend=false)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Or we can get the complex transfer coefficient or the transmission loss in dB:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> transfercoef(pm, tx, rx)\n0.012626450940400389 + 0.013059816794863028im\n\njulia> transmissionloss(pm, tx, rx)\n34.81504382385067","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"You can also pass in arrays of sources and receivers, if you want many transmission losses to be computed simultanously. Some models are able to compute transmission loss on a Cartesion grid very efficiently. This is useful to plot transmission loss as a function of space.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To define a 1000×200 Cartesion grid with 0.1 m spacing:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> rx = AcousticReceiverGrid2D(1.0, 0.1, 1000, -20.0, 0.1, 200)\n1000×200 AcousticReceiverGrid2D{Float64}:\n BasicAcousticReceiver((1.0, 0.0, -20.0))    …  BasicAcousticReceiver((1.0, 0.0, -0.1))\n BasicAcousticReceiver((1.1, 0.0, -20.0))       BasicAcousticReceiver((1.1, 0.0, -0.1))\n BasicAcousticReceiver((1.2, 0.0, -20.0))       BasicAcousticReceiver((1.2, 0.0, -0.1))\n ⋮                                           ⋱\n BasicAcousticReceiver((100.7, 0.0, -20.0))     BasicAcousticReceiver((100.7, 0.0, -0.1))\n BasicAcousticReceiver((100.8, 0.0, -20.0))     BasicAcousticReceiver((100.8, 0.0, -0.1))\n BasicAcousticReceiver((100.9, 0.0, -20.0))     BasicAcousticReceiver((100.9, 0.0, -0.1))","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We can then compute the transmission loss over the grid:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> x = transmissionloss(pm, tx, rx)\n1000×200 Array{Float64,2}:\n 19.0615  19.2409  19.7973  18.9816  …  10.3091  11.5716   9.09088  16.5205\n 19.0662  19.2454  19.8034  18.9854     10.4667  11.5171   9.09217  16.5845\n 19.0924  19.2709  19.8367  19.0079  …  11.2588  11.2684   9.09648  16.881\n 19.1011  19.2794  19.8477  19.0158     11.499   11.2005   9.09736  16.9633\n  ⋮                 ⋮                ⋱   ⋮                 ⋮\n 36.537   36.8455  38.2986  39.8524     46.4645  50.3007  51.5835   53.2666\n 36.6307  36.9485  38.4409  40.0359  …  46.7645  50.7011  51.9972   53.3554\n 36.6801  37.0024  38.5142  40.1293     46.9185  50.9075  52.2096   53.3968\n 36.838   37.174   38.7423  40.4151     47.396   51.5509  52.8682   53.5073\n\njulia> plot(env; receivers=rx, transmissionloss=x)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"index.html#Acoustic-simulations","page":"Home","title":"Acoustic simulations","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Apart from propagation modeling, we can also setup a simulation with various sources and receviers.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We demonstrate this by setting up a scenario with two pingers (1 kHz, 10 ms pulse with 1 Hz PRR; 2 kHz, 20 ms pulse with 2 Hz PRR) with a source level of 170 dB re µPa @ 1m, at two locations, and deploying two omnidirectional receviers to record them:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using DSP: db2amp\njulia> tx = [\n  Pinger(0.0, 0.0, -5.0, 1000.0; interval=1.0, duration=10e-3, sourcelevel=db2amp(170)),\n  Pinger(0.0, 100.0, -5.0, 2000.0; interval=0.5, duration=20e-3, sourcelevel=db2amp(170))\n]\n\njulia> rx = [\n  AcousticReceiver(100.0, 0.0, -10.0);\n  AcousticReceiver(50.0, 20.0, -5.0)\n];","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To carry out the simulation, we can for a 2-second long recording (at 8 kSa/s) at the receivers:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> s = record(pm, tx, rx, 2.0, 8000.0)\nSampledSignal @ 8000.0 Hz, 16000×2 Array{Complex{Float64},2}:\n  127308.0+884666.0im   1.15927e6-548579.0im\n -263820.0+1.16962e6im   1.1377e6+541803.0im\n  -80980.6+1.16562e6im   657226.0+738712.0im\n          ⋮\n -447370.0+910253.0im    163952.0-436691.0im\n -431239.0+903852.0im    100509.0-118066.0im\n -391797.0+582705.0im     49383.0-679981.0im","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The signals are returned as complex analytic signals, but can be easily converted to real signals, if desired:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> s = real(s)\nSampledSignal @ 8000.0 Hz, 16000×2 Array{Float64,2}:\n -672702.0   318731.0\n -825049.0   377382.0\n -984626.0   214490.0\n       ⋮\n   66193.3  -497239.0\n -144031.0  -321312.0\n -260200.0  -235680.0","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To visualize the recording, we plot a spectrogram of the signal at the first receiver with the SignalAnalysis.jl package:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using SignalAnalysis\njulia> specgram(s[:,1])","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We can clearly see the two pingers, as well as the ambient noise generated with the noise model defined in the environment description.","category":"page"}]
}
